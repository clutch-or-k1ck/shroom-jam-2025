extends Node2D
class_name Bombardier

"""
NOTE bomb throwing pattern is just a dictionary that defines when and where to spawn bombs
its keys are times (starts at 0.) when to spawn the bombs
each key is an array of positions where to spawn bombs, as ratios of screen width
the bomb spawner first spawns the shadow of the bomb (if available), then it spawns the bomb with delay
the bomb is always spawned right outside the screen boundary
"""

## this sfx will be played when the new bombing starts
@export var sfx: Resource


## when bombardment is finished
signal bombardment_finished


var _elapsed_bombing_time := 0.
var _active_pattern: Dictionary = {}

@onready var bomb_drop_scene := preload('res://scenes/bombardment_system/bomb_drop.tscn')


#region Bombing patterns

## contains a collection of methods to generate certain bomb throwing patterns
class Patterns:
	
	func _random(spec: Variant) -> Variant:
		if spec is float or spec is int:
			return spec
		elif spec is Array:
			if spec[0] is float:
				return randf_range(spec[0], spec[1])
			elif spec[1] is int:
				return randi_range(spec[0], spec[1])
		return NAN
	
	## bombs falling left to right, starts at 'location', bombs are separated spatially by 'step', in time by 'interval'
	## the carpet has a given length. location, step, and length are all fractions of viewport space
	func carpet(location: float, step: float, length: float, interval: float) -> Dictionary:
		var pattern := {}
		
		var number_of_bombs_to_throw := floor(length / step) as int
		
		for i in range(0, number_of_bombs_to_throw):
			# NOTE do not throw outside screen boundaries
			if location + step * i > 1.:
				continue
			pattern[interval * i] = [location + step * i]
			
		return pattern
		
	## bombs falling in the checker pattern. you can tweak number of rows to fall, number of columns, and time interval between them
	func checker(column_number: int, row_number: int, interval: float) -> Dictionary:
		var pattern := {}
		
		var cell_size = 1. / column_number
		
		for i in range(row_number):
			var locations := []
			
			var idx := i % 2
			while idx < column_number:
				locations.append(idx * cell_size + cell_size / 2.)
				idx += 2
				
			pattern[interval * i] = locations
			
		return pattern
		
	## bombs are falling randomly, you can tweak how many bombs will fall, as well as interval
	func random(number: int, interval: float) -> Dictionary:
		var pattern := {}
		
		for i in range(number):
			pattern[interval + i] = [randf_range(0.2, 0.8)]
			
		return pattern
		
	## bombs are falling at both ends of screen space, slowly coming to its center
	func grip(number: int, interval: float) -> Dictionary:
		var pattern := {}
		
		# divide the viewport into cells and store cell center locations
		number += number % 2 # NOTE enforce even number
		var cell_size := 1. / number
		
		var spawn_cells = []
		for i in range(number):
			spawn_cells.append(i * cell_size + cell_size / 2.)
			
		for i in range(number / 2):
			pattern[interval * i] = [spawn_cells[i], spawn_cells[-i-1]]
			
		return pattern
	
	## bombs are falling into one particular location
	func focus(location: float, number: int, interval: float, variance: float = 0.05) -> Dictionary:
		var pattern := {}
		for i in range(number):
			pattern[interval * i] = [location + randf_range(-variance, variance)]
		return pattern
		
	## returns a pattern randomly generated by one of the other methods
	## NOTE randomization params contain method.param as keys, and Vector2 as values
	## for example: carpet.location = Vector2(0.5, 0.7), meaning spawn carpet from 0.5 to 0.7
	func get_random_pattern(randomization_param_overrides: Dictionary = {}) -> Dictionary:
		var randomization_params := {
			'carpet.location': [0., 0.5],
			'carpet.step': 0.1,
			'carpet.length': 0.5,
			'carpet.interval': 0.1,
			'checker.column_number': 5,
			'checker.row_number': 6,
			'checker.interval': 1.5,
			'random.number': 10,
			'random.interval': 1.,
			'grip.number': 10,
			'grip.interval': 2.,
			'focus.location': [0.3, 0.7],
			'focus.number': 10,
			'focus.interval': 0.4,
			'focus.variance': 0.07
		}
		
		for override in randomization_param_overrides:
			randomization_params[override] = randomization_param_overrides[override]
		
		# NOTE just an alis to keep code concise
		var _rand_parm = func _rand_parm(id: String):
			return _random(randomization_params[id])
			
		var pattern := {}
		
		var method_idx := randi_range(1, 5)
		match method_idx:
			1:
				pattern = carpet(
					_rand_parm.call('carpet.location'), 
					_rand_parm.call('carpet.step'), 
					_rand_parm.call('carpet.length'), 
					_rand_parm.call('carpet.interval')
				)
			2:
				pattern = checker(
					_rand_parm.call('checker.column_number'), 
					_rand_parm.call('checker.row_number'), 
					_rand_parm.call('checker.interval')
				)
			3:
				pattern = random(
					_rand_parm.call('random.number'),
					_rand_parm.call('random.interval')
				)
			4:
				pattern = grip(
					_rand_parm.call('random.number'),
					_rand_parm.call('random.interval')
				)
			5:
				pattern = focus(
					_rand_parm.call('focus.location'),
					_rand_parm.call('focus.number'),
					_rand_parm.call('focus.interval'),
					_rand_parm.call('focus.variance')
				)
				
		return pattern
#endregion


func do_spawn(locations: Array) -> void:
	for location_ratio in locations:
		var global_loc_x = get_viewport_rect().size.x * location_ratio
		var new_bomb_drop := bomb_drop_scene.instantiate()
		add_child(new_bomb_drop)
		new_bomb_drop.position = Vector2(global_loc_x, 0.)


## every tick, check if there are bombs to throw
func _process(delta: float) -> void:
	if not _active_pattern.is_empty():
		for throwing_instant in _active_pattern:
			if _elapsed_bombing_time >= throwing_instant:
				do_spawn(_active_pattern[throwing_instant])
				_active_pattern.erase(throwing_instant)
		if _active_pattern.is_empty(): # NOTE means we just finished bombing
			bombardment_finished.emit()

	_elapsed_bombing_time += delta

## throw bombs following a pattern
func throw_bombs(pattern: Dictionary, initial_delay: float = 0.) -> void:
	_elapsed_bombing_time = -initial_delay
	_active_pattern = pattern
